---
title: "Possible to coexist with custom ControllerFactory? Or...how to redo that"
---
<div id="post1202682" class="discussion-comment op">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-04T14:10:24.427-08:00" title="2014-02-04T14:10:24.427-08:00">February 4, 2014</time>
   </div>
   <div class="discussion-message">Hello,<br />
<br />
I'm trying to augment an existing system so that it can use MvcCodeRouting.<br />
<br />
A problem I'm facing is that this system has code like this:<br />
<br />
I don't see anywhere in the MvcCodeRouting code where you actually create an IControllerFactory, so I'm wondering is there some way I could delegate to MvcCodeRouting if-and-when this other factory cannot find a &quot;suitable controller&quot;? <br />
<br />
Thanks!<br />
<pre><code>public class IceNineControllerFactory : IControllerFactory
{
    public static readonly IControllerFactory Instance = new IceNineControllerFactory();
    private static readonly ControllerTypeCache _staticControllerTypeCache = new ControllerTypeCache();

    private IceNineControllerFactory() {}

    IController IControllerFactory.CreateController(RequestContext requestContext, string controllerName)
    {
        if (requestContext == null)
            throw new ArgumentNullException(&quot;requestContext&quot;);
        if (string.IsNullOrEmpty(controllerName))
            throw new ArgumentException(&quot;Value not specified&quot;, &quot;controllerName&quot;);
        Type controllerType = GetControllerType(requestContext, controllerName);
        if (controllerType == null)
            throw new HttpException((int)HttpStatusCode.NotFound, string.Format(&quot;No suitable controller class found: {0}&quot;, requestContext.HttpContext.Request.Path));

        new RequestParameterBuilder(Locator.Resolve&lt;IEntitySpaceManager&gt;().GetRequestEntitySpace())
            .LoadParameters(requestContext.HttpContext.Request.Form, requestContext.HttpContext.Request.QueryString);

        return GetControllerInstance(controllerType);
    }</code></pre>

</div>
</div>
<div id="post1202687" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-04T14:26:54.097-08:00" title="2014-02-04T14:26:54.097-08:00">February 4, 2014</time> <a href="#post1202687" class="post-link">link</a></div>
   <div class="discussion-message">Ok, so I was able to do that like this:<br />
<pre><code>        if (controllerType == null)
        {
            var controller = VersionOne.Web.IceNine.Shim.IceNineCore.OriginalControllerFactory.CreateController(requestContext, controllerName);
            if (controller == null)
                throw new HttpException((int)HttpStatusCode.NotFound, string.Format(&quot;No suitable controller class found: {0}&quot;, requestContext.HttpContext.Request.Path));
            return controller;
        }
</code></pre>

Since your code is simple and unobtrusive, all it does is populate the routes table and allow Mvc to do it's normal controller creation job. So, I saved a reference to the &quot;OriginalControllerFactory&quot;, and just delegated to it!<br />
</div>
</div>
<div id="post1202702" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-04T15:41:53.533-08:00" title="2014-02-04T15:41:53.533-08:00">February 4, 2014</time> <a href="#post1202702" class="post-link">link</a></div>
   <div class="discussion-message">Yep, MVC supports finding controllers by namespace, so I just let it do its thing. Although, it wouldn't work in the super rare case two assemblies have controllers with the same namespace.<br />
<br />
On Web API however I do register a custom controller selector.<br />
</div>
</div>
<div id="post1202749" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-04T20:03:54.59-08:00" title="2014-02-04T20:03:54.59-08:00">February 4, 2014</time> <a href="#post1202749" class="post-link">link</a></div>
   <div class="discussion-message"><strong>maxtoroq wrote:</strong><br />
<blockquote>
Yep, MVC supports finding controllers by namespace, so I just let it do its thing. Although, it wouldn't work in the super rare case two assemblies have controllers with the same namespace.<br />
<br />
On Web API however I do register a custom controller selector.<br />
</blockquote>
Thanks Max, I think I am getting close, but still having some head-scratching issues.<br />
<br />
First of all, I'm using F# with a MEF-based module loader I rewrote from C#. That part seems to be working fine. But I'm not sure I'm getting things correct.<br />
<br />
Here's my routes.axd output:<br />
<pre><code>// MvcCodeRouting v1.2.0
// Format: C# - Visual Basic

#region Arena

routes.MapRoute(null, &quot;Arena/Get&quot;, 
    new { controller = &quot;Arena&quot;, action = &quot;Get&quot; }, 
    new[] { &quot;VersionOne.Arena&quot; });

routes.MapHttpRoute(null, &quot;Arena/Api&quot;, 
    new { controller = &quot;Api&quot; });

routes.MapRoute(null, &quot;Arena/Web/Get&quot;, 
    new { controller = &quot;Web&quot;, action = &quot;Get&quot; }, 
    new[] { &quot;VersionOne.Arena.Web&quot; });

#endregion
</code></pre>

I was not expecting that. I was expecting Arena/Api, Arena/Api/ByName, Arena/Api/Version, Arena/Api/NewEndpoint<br />
<br />
And, Arena/Web/Get <br />
<br />
Because, here are the controllers that I used:<br />
<pre><code>namespace VersionOne.Arena

open System
//open System.Web.Http
open System.Net.Http
open System.Net
open System.Web.Mvc
open VersionOne.Arena.Intrastructure.Web

type ArenaController() =
    inherit Controller()
    member this.Get() =
        this.Content(&quot;Nothing to see here&quot;)

type public ArenaModule() =
    inherit DefaultModule&lt;ArenaController&gt;()
    override this.GetBaseControllerRoute() = 
        &quot;Arena&quot;

namespace VersionOne.Arena.Api

open System
open System.Web.Http
open System.Net.Http
open System.Net
open System.Web.Mvc
open VersionOne.Arena.Intrastructure.Web

type ApiController() =
    inherit System.Web.Http.ApiController()
    member this.Get () =
        this.Request.CreateResponse(HttpStatusCode.OK, &quot;We got it! Here's your messages!&quot;)

    [&lt;HttpGet&gt;]
    member this.ByName (name : string) =
        this.Request.CreateErrorResponse(HttpStatusCode.OK, &quot;Thanks! Here's your name: &quot; + name)

    [&lt;HttpGet&gt;]
    member this.Version () =
        this.Request.CreateErrorResponse(HttpStatusCode.OK, &quot;Version B&quot;)

    [&lt;HttpGet&gt;]
    member this.NewEndpoint () =
        this.Request.CreateErrorResponse(HttpStatusCode.OK, &quot;Hey I did not exist in Version A!&quot;)

namespace VersionOne.Arena.Web

open System
open System.Web.Http
open System.Net.Http
open System.Net
open System.Web.Mvc
open VersionOne.Arena.Intrastructure.Web

type WebController() =
    inherit Controller()
    
    [&lt;HttpGet&gt;]
    member this.Get() = 
        this.View()
</code></pre>

So, those are the controllers. Here's the IModule definition, and the ModuleLoader:<br />
<pre><code>namespace VersionOne.Arena.Infrastructure.Composition

open System
open System.ComponentModel.Composition

type MapCodeRoutesDelegate = delegate of String * Type -&gt; unit

[&lt;InheritedExport(typedefof&lt;IModule&gt;)&gt;]
type IModule =
    abstract member Initialize : callback : MapCodeRoutesDelegate -&gt; unit

namespace VersionOne.Arena.Intrastructure.Web

open System.ComponentModel.Composition
open VersionOne.Arena.Infrastructure.Composition

[&lt;AbstractClass&gt;]
type DefaultModule&lt;'T&gt;() =
    abstract member GetBaseControllerRoute : unit -&gt; string
    interface IModule with
        member this.Initialize mapCodeRoutesDelegate =
            let baseControllerRoute = this.GetBaseControllerRoute()
            mapCodeRoutesDelegate.Invoke(baseControllerRoute, typedefof&lt;'T&gt;)
</code></pre>

The ModuleLoader:<br />
<br />
This is where I'm having the most difficulty. At first I messed up and didn't use MvcCodeRouting.Web.Http.WebHost. I just used MvcCodeRouting.Web.Http.<br />
<br />
I have used a very similar approach before, though written in C#. The original code is buried in this prior commit on this branch:  <a href="https://github.com/JogoShugh/ModularAspNetMvc/blob/2102ac8f96d7bda87b5d25886587e2facb350a12/FieldReporting.Infrastructure/Ui/Mvc/Modularity/ModuleLoader.cs" rel="nofollow">https://github.com/JogoShugh/ModularAspNetMvc/blob/2102ac8f96d7bda87b5d25886587e2facb350a12/FieldReporting.Infrastructure/Ui/Mvc/Modularity/ModuleLoader.cs</a><br />
<pre><code>namespace VersionOne.Arena.Infrastructure.Composition

open System
open System.Web.Routing
open System.Web
open System.Web.Http
open System.ComponentModel.Composition
open MvcCodeRouting

module ModuleFuncs =
    let mapCodeRoutes (baseRoute : String) (rootControllerType: Type) =
        let routes = RouteTable.Routes
        let settings = CodeRoutingSettings()        
        settings.UseImplicitIdToken &lt;- true
        settings.EnableEmbeddedViews &lt;- true
        //settings.Configuration &lt;- GlobalConfiguration.Configuration
        //GlobalConfiguration.Configuration.MapCodeRoutes(baseRoute, rootControllerType, settings) |&gt; ignore
        routes.MapCodeRoutes(baseRoute, rootControllerType, settings) |&gt; ignore

type ModuleLoader() =
    member this.LoadAllModules () =
        let callback = MapCodeRoutesDelegate(ModuleFuncs.mapCodeRoutes)
        let parts = PartsList&lt;IModule&gt;(fun m -&gt; m.Initialize(callback) ) |&gt; ignore
        ()</code></pre>

I ran into issues with using System.Web.Mvc; and using System.Web.Http, each have an HttpGet attribute!!!!<br />
<br />
But, I think I solved it now :-D<br />
<br />
I'll revise this post int he morning. I'm tired now.<br />
<br />
NOTE TO SELF:<br />
<br />
I'm at the point with these routes now:<br />
<pre><code>#region Arena

routes.MapRoute(null, &quot;Arena/Get&quot;, 
    new { controller = &quot;Arena&quot;, action = &quot;Get&quot; }, 
    new[] { &quot;VersionOne.Arena&quot; });

routes.MapHttpRoute(null, &quot;Arena/Api/{action}&quot;, 
    new { controller = &quot;Api&quot;, action = RouteParameter.Optional }, 
    new { action = new SetRouteConstraint(&quot;ByName&quot;, &quot;Version&quot;, &quot;NewEndpoint&quot;) });

routes.MapRoute(null, &quot;Arena/Web/Get&quot;, 
    new { controller = &quot;Web&quot;, action = &quot;Get&quot; }, 
    new[] { &quot;VersionOne.Arena.Web&quot; });

#endregion</code></pre>

The API ones work great. The others, not so much.<br />
<pre><code>#region Arena

routes.MapHttpRoute(null, &quot;Arena/{action}&quot;, 
    new { controller = &quot;Arena&quot;, action = RouteParameter.Optional }, 
    new { action = new SetRouteConstraint(&quot;ByName&quot;, &quot;Version&quot;, &quot;NewEndpoint&quot;) });

#endregion</code></pre>

I still have the old code, because I pasted it to a coworker. Here it is:<br />
<pre><code>type ArenaController() =
    inherit ApiController()
    member this.Get() =
        this.Request.CreateResponse(HttpStatusCode.OK, &quot;We got it! Here's your messages!&quot;)

    [&lt;HttpGet&gt;]
    member this.ByName name =
        this.Request.CreateErrorResponse(HttpStatusCode.OK, &quot;Thanks! Here's your name: &quot; + name)

    [&lt;HttpGet&gt;]
    member this.Version() =
        this.Request.CreateErrorResponse(HttpStatusCode.OK, &quot;Version B&quot;)

    [&lt;HttpGet&gt;]
    member this.NewEndpoint() =
        this.Request.CreateErrorResponse(HttpStatusCode.OK, &quot;Hey I did not exist in Version A!&quot;)


//[&lt;Export(typedefof&lt;IModule&gt;)&gt;]
type public ArenaModule() =
    inherit DefaultModule&lt;ArenaController&gt;()
    override this.GetBaseControllerRoute () = 
        &quot;Arena&quot;</code></pre>

When I decompile to C# with Telerik, I get this:<br />
<br />
OLD DLL:<br />
<pre><code>
using Microsoft.FSharp.Core;
using System;
using VersionOne.Arena.Intrastructure.Web;

namespace VersionOne.Arena
{
    [CompilationMapping(SourceConstructFlags.ObjectType)]
    [Serializable]
    public class ArenaModule : DefaultModule&lt;ArenaController&gt;
    {
        public ArenaModule()
        {
        }

        public override string GetBaseControllerRoute()
        {
            return &quot;Arena&quot;;
        }
    }
}


using Microsoft.FSharp.Core;
using System;
using System.Net;
using System.Net.Http;
using System.Web.Http;

namespace VersionOne.Arena
{
    [CompilationMapping(SourceConstructFlags.ObjectType)]
    [Serializable]
    public class ArenaController : ApiController
    {
        public ArenaController()
        {
        }

        [HttpGet]
        public HttpResponseMessage ByName(string name)
        {
            return this.Request.CreateErrorResponse(HttpStatusCode.OK, string.Concat(&quot;Thanks! Here's your name: &quot;, name));
        }

        public HttpResponseMessage Get()
        {
            return this.Request.CreateResponse&lt;string&gt;(HttpStatusCode.OK, &quot;We got it! Here's your messages!&quot;);
        }

        [HttpGet]
        public HttpResponseMessage NewEndpoint()
        {
            return this.Request.CreateErrorResponse(HttpStatusCode.OK, &quot;Hey I did not exist in Version A!&quot;);
        }

        [HttpGet]
        public HttpResponseMessage Version()
        {
            return this.Request.CreateErrorResponse(HttpStatusCode.OK, &quot;Version B&quot;);
        }
    }
}
</code></pre>

NEW BUILD:<br />
<pre><code>using Microsoft.FSharp.Core;
using System;
using VersionOne.Arena.Intrastructure.Web;

namespace VersionOne.Arena
{
    [CompilationMapping(SourceConstructFlags.ObjectType)]
    [Serializable]
    public class ArenaModule : DefaultModule&lt;ArenaController&gt;
    {
        public ArenaModule()
        {
        }

        public override string GetBaseControllerRoute()
        {
            return &quot;Arena&quot;;
        }
    }
}

using Microsoft.FSharp.Core;
using System;
using System.Net;
using System.Net.Http;
using System.Web.Http;
using System.Web.Mvc; // &lt;--- THE OFFENDER

namespace VersionOne.Arena
{
    [CompilationMapping(SourceConstructFlags.ObjectType)]
    [Serializable]
    public class ArenaController : ApiController
    {
        public ArenaController()
        {
        }

        [HttpGet]
        public HttpResponseMessage ByName(string name)
        {
            return this.Request.CreateErrorResponse(HttpStatusCode.OK, string.Concat(&quot;Thanks! Here's your name: &quot;, name));
        }

        public HttpResponseMessage Get()
        {
            return this.Request.CreateResponse&lt;string&gt;(HttpStatusCode.OK, &quot;We got it! Here's your messages!&quot;);
        }

        [HttpGet]
        public HttpResponseMessage NewEndpoint()
        {
            return this.Request.CreateErrorResponse(HttpStatusCode.OK, &quot;Hey I did not exist in Version A!&quot;);
        }

        [HttpGet]
        public HttpResponseMessage Version()
        {
            return this.Request.CreateErrorResponse(HttpStatusCode.OK, &quot;Version B&quot;);
        }
    }
}
</code></pre>

</div>
</div>
<div id="post1202754" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-04T20:41:21.083-08:00" title="2014-02-04T20:41:21.083-08:00">February 4, 2014</time> <a href="#post1202754" class="post-link">link</a></div>
   <div class="discussion-message">That's a lot to take in :)<br />
<br />
<strong>Some tips</strong><br />
<br />
In MVC:<br />
<br />
Controllers:<br />
<pre><code>using System.Web.Mvc;
using MvcCodeRouting.Web.Mvc;</code></pre>

Registration:<br />
<pre><code>RouteTable.Routes.MapCodeRoutes()</code></pre>

In Web API:<br />
<br />
Controllers:<br />
<pre><code>using System.Web.Http;
using MvcCodeRouting.Web.Http;</code></pre>

Registration (WebHost):<br />
<pre><code>RouteTable.Routes.MapCodeRoutes()</code></pre>

Registration (SelfHost):<br />
<pre><code>configuration.MapCodeRoutes()</code></pre>

</div>
</div>
<div id="post1202935" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T05:30:20.667-08:00" title="2014-02-05T05:30:20.667-08:00">February 5, 2014</time> <a href="#post1202935" class="post-link">link</a></div>
   <div class="discussion-message">Max, thanks for your fast responses. I really appreciate it! This is our &quot;hack week&quot; where we get to build whatever we want and demo on Friday to 120 people. What I am trying to build is a plugin system for the application at <a href="http://www.VersionOne.com" rel="nofollow">www.VersionOne.com</a>. It would be awesome for us because we can start breaking the app into more discrete bundles and deliver updates like that. I plan to combine the mvccoderouting part with a recipe I found in Apress Pro NuGet book that shows how create plugins with MEF as NuGet packages for your own app, utilizing NuGet.Core to download packages and perform shadow copying and app restart and all that stuff. Our Interaction Designer can't wait to see this in action because she wants to be able to tell users to &quot;try out&quot; early access or &quot;beta&quot; features without them needing a whole new build. The idea is that we'll have a private NuGet feed which lists the available modules and their versions and the administrator can pop one in or swap it out or turn off others. <br />
<br />
Anyway.....<br />
So, the last step I think is to make sure Embedded Views can work right for MVC UI.<br />
<br />
Do I have to make two distinct calls if I have a single module with both API and MVC controllers?<br />
<br />
In my module I have the ArenaApiController : ApiController and also WebController : Controller. <br />
<br />
Earlier I had been making separate calls but then I read in the docs that you don't have to, you can make a single call and that the controllers could be either. When I debugged and stepped through I saw the provider checks and the criteria being the typeof checks, ! IsAbstract, IsPublic, etc.... <br />
<br />
And, when I did make two separate calls the routes were all kinds of mangled, now it is at least recognizing both API and Web, but only Api is working.<br />
<br />
I will go edit last nights post. It was very late and I was experimenting with it for about 8 hours at that point :)<br />
<br />
Thanks again for all your help, and for this project in general.<br />
<br />
It was almost 8 years ago when I asked about modular asp.net apps: <a href="http://forums.asp.net/t/1005483.aspx" rel="nofollow">http://forums.asp.net/t/1005483.aspx</a><br />
<br />
At that point the best example I knew of was DotNetNuke, and maybe it still is. But, your project is making it possible in a better way, especially if I can get the embedded resources to work. In F# I had to add a manual compiler flag for --resource: because it doesn't even give you a project tab for it haha.<br />
<br />
<br />
<br />
<strong>maxtoroq wrote:</strong><br />
<blockquote>
That's a lot to take in :)<br />
<br />
<strong>Some tips</strong><br />
<br />
In MVC:<br />
<br />
Controllers:<br />
<pre><code>using System.Web.Mvc;
using MvcCodeRouting.Web.Mvc;</code></pre>

Registration:<br />
<pre><code>RouteTable.Routes.MapCodeRoutes()</code></pre>

In Web API:<br />
<br />
Controllers:<br />
<pre><code>using System.Web.Http;
using MvcCodeRouting.Web.Http;</code></pre>

Registration (WebHost):<br />
<pre><code>RouteTable.Routes.MapCodeRoutes()</code></pre>

Registration (SelfHost):<br />
<pre><code>configuration.MapCodeRoutes()</code></pre>

</blockquote>
</div>
</div>
<div id="post1202959" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T06:09:05.703-08:00" title="2014-02-05T06:09:05.703-08:00">February 5, 2014</time> <a href="#post1202959" class="post-link">link</a></div>
   <div class="discussion-message">That's right, you <strong>don't</strong> need to make different calls for MVC and API controllers.<br />
<br />
What you are building sounds cool, any chance you make it open source? :-)<br />
</div>
</div>
<div id="post1202960" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T06:10:51.813-08:00" title="2014-02-05T06:10:51.813-08:00">February 5, 2014</time> <a href="#post1202960" class="post-link">link</a></div>
   <div class="discussion-message">Note: I am using MVC 5.1, not 5.0.<br />
<br />
To summarize where I'm at to this point, my routes now look like this:<br />
<pre><code>#region Arena

routes.MapRoute(null, &quot;Arena/Get&quot;, 
    new { controller = &quot;Arena&quot;, action = &quot;Get&quot; }, 
    new[] { &quot;VersionOne.Arena&quot; });

routes.MapHttpRoute(null, &quot;Arena/Api/{action}&quot;, 
    new { controller = &quot;Api&quot;, action = RouteParameter.Optional }, 
    new { action = new SetRouteConstraint(&quot;ByName&quot;, &quot;Version&quot;, &quot;NewEndpoint&quot;) });

routes.MapRoute(null, &quot;Arena/Web/Get&quot;, 
    new { controller = &quot;Web&quot;, action = &quot;Get&quot; }, 
    new[] { &quot;VersionOne.Arena.Web&quot; });

#endregion</code></pre>

Of those, the Arena/Api ones work perfectly. The others are not working at all, and I cannot figure out why. I just get a 404, resource not found if I attempt Arena/Get or Arena/ or Arena/Web/Get or Arena/Web.<br />
<br />
The controllers are defined like this:<br />
<pre><code>namespace VersionOne.Arena

open System
open System.Web.Http
open System.Net.Http
open System.Net
open VersionOne.Arena.Intrastructure.Web
// --resource:&quot;Views\Arena\Get.spark&quot;,&quot;VersionOne.Arena.Module.Views.Arena.Get.spark&quot;

type ArenaController() =
    inherit System.Web.Mvc.Controller()
    member this.Get() =
        this.Content(&quot;Nothing to see here&quot;)

type public ArenaModule() = 
    inherit DefaultModule&lt;ArenaController&gt;()
    override this.GetBaseControllerRoute() = 
        &quot;Arena&quot;

namespace VersionOne.Arena.Api

open System
open System.Web.Http
open System.Net.Http
open System.Net
open VersionOne.Arena.Intrastructure.Web

type ApiController() =
    inherit System.Web.Http.ApiController()
    member this.Get () = &quot;We got it! Here's your messages!&quot;

    [&lt;HttpGet&gt;]
    member this.ByName name = &quot;Thanks! Here's your name: &quot; + name

    [&lt;HttpGet&gt;]
    member this.Version () = &quot;Version B&quot;

    [&lt;HttpGet&gt;]
    member this.NewEndpoint () = &quot;Hey I did not exist in Version A!&quot;

namespace VersionOne.Arena.Web

open System
open System.Web.Http
open System.Net.Http
open System.Net
open VersionOne.Arena.Intrastructure.Web

type WebController() =
    inherit System.Web.Mvc.Controller()
    
    [&lt;System.Web.Mvc.HttpGet&gt;] // Just playing around with this...
    member this.Get() = 
        this.View() </code></pre>

And, my configuration for routing is below. I didn't need to open MvcCodeRourting.Web.Http or MvcCodeRouting.Web.Mvc. When I did examine those. MvcCodeRouting.CodeRoutingExtensions has extends RouteCollection, so isn't this the right way?<br />
<pre><code>namespace VersionOne.Arena.Infrastructure.Composition

open System
open System.Web.Routing
open MvcCodeRouting

module ModuleFuncs =
    let mapCodeRoutes (baseRoute : String) (rootControllerType: Type) =
        let routes = System.Web.Routing.RouteTable.Routes
        let settings = CodeRoutingSettings()        
        settings.UseImplicitIdToken &lt;- true
        settings.EnableEmbeddedViews &lt;- true
        //settings.Configuration &lt;- GlobalConfiguration.Configuration
        //GlobalConfiguration.Configuration.MapCodeRoutes(baseRoute, rootControllerType, settings) |&gt; ignore
        routes.MapCodeRoutes(baseRoute, rootControllerType, settings) |&gt; ignore

type ModuleLoader() =
    member this.LoadAllModules () =
        let callback = MapCodeRoutesDelegate(ModuleFuncs.mapCodeRoutes)
        let parts = PartsList&lt;IModule&gt;(fun m -&gt; m.Initialize(callback) ) |&gt; ignore
        ()</code></pre>

</div>
</div>
<div id="post1202961" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T06:12:29.75-08:00" title="2014-02-05T06:12:29.75-08:00">February 5, 2014</time> <a href="#post1202961" class="post-link">link</a></div>
   <div class="discussion-message">Definitely! I'd love to. I'll have to break it out along-side our Core app and into our main set of open source offering, but I don't see any reason why not.<br />
<br />
We have a lot of open source in our github accounts at <a href="https://github.com/versionone" rel="nofollow">https://github.com/versionone</a><br />
</div>
</div>
<div id="post1202964" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T06:20:46.54-08:00" title="2014-02-05T06:20:46.54-08:00">February 5, 2014</time> <a href="#post1202964" class="post-link">link</a></div>
   <div class="discussion-message">Perhaps your custom controller factory is messing something up?<br />
<br />
About <code>Arena/Get</code>, if you intend to ommit <code>Get</code> from the URL you should name it Index, or use the <code>[DefaultAction]</code> attribute. This applies to MVC only.<br />
</div>
</div>
<div id="post1202970" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T06:28:44.97-08:00" title="2014-02-05T06:28:44.97-08:00">February 5, 2014</time> <a href="#post1202970" class="post-link">link</a></div>
   <div class="discussion-message">Ok I'll try that. It may be possible about the custom factory, although no breakpoints are hitting where that thing normally runs.<br />
. . .<br />
<br />
When I tried that, I get routes like this:<br />
<pre><code>#region Arena

routes.MapRoute(null, &quot;Arena/{action}&quot;, 
    new { controller = &quot;Arena&quot;, action = &quot;Get&quot; }, 
    new { action = new SetRouteConstraint(&quot;Get&quot;) }, 
    new[] { &quot;VersionOne.Arena&quot; });

routes.MapHttpRoute(null, &quot;Arena/Api/{action}&quot;, 
    new { controller = &quot;Api&quot;, action = RouteParameter.Optional }, 
    new { action = new SetRouteConstraint(&quot;ByName&quot;, &quot;Version&quot;, &quot;NewEndpoint&quot;) });

routes.MapRoute(null, &quot;Arena/Web/{action}&quot;, 
    new { controller = &quot;Web&quot;, action = &quot;Get&quot; }, 
    new { action = new SetRouteConstraint(&quot;Get&quot;) }, 
    new[] { &quot;VersionOne.Arena.Web&quot; });

#endregion</code></pre>

That looked promising to me, but the same results, 404 for Arena/ Arena/Get Arena/Web and Arena/Web/Get<br />
<br />
Code:<br />
<pre><code>namespace VersionOne.Arena

open System
open System.Web.Http
open System.Net.Http
open System.Net
open VersionOne.Arena.Intrastructure.Web
// --resource:&quot;Views\Arena\Get.spark&quot;,&quot;VersionOne.Arena.Module.Views.Arena.Get.spark&quot;

type ArenaController() =
    inherit System.Web.Mvc.Controller()
    [&lt;MvcCodeRouting.Web.Mvc.DefaultAction&gt;]    
    member this.Get() =
        this.Content(&quot;Nothing to see here&quot;)

type public ArenaModule() = 
    inherit DefaultModule&lt;ArenaController&gt;()
    override this.GetBaseControllerRoute() = 
        &quot;Arena&quot;

namespace VersionOne.Arena.Api

open System
open System.Web.Http
open System.Net.Http
open System.Net
open VersionOne.Arena.Intrastructure.Web

type ApiController() =
    inherit System.Web.Http.ApiController()
    member this.Get () = &quot;We got it! Here's your messages!&quot;

    [&lt;HttpGet&gt;]
    member this.ByName name = &quot;Thanks! Here's your name: &quot; + name

    [&lt;HttpGet&gt;]
    member this.Version () = &quot;Version B&quot;

    [&lt;HttpGet&gt;]
    member this.NewEndpoint () = &quot;Hey I did not exist in Version A!&quot;

namespace VersionOne.Arena.Web

open System
open System.Web.Http
open System.Net.Http
open System.Net
open VersionOne.Arena.Intrastructure.Web

type WebController() =
    inherit System.Web.Mvc.Controller()    
    [&lt;MvcCodeRouting.Web.Mvc.DefaultAction&gt;]    
    member this.Get() = 
        this.View() </code></pre>

</div>
</div>
<div id="post1202987" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T06:44:32.873-08:00" title="2014-02-05T06:44:32.873-08:00">February 5, 2014</time> <a href="#post1202987" class="post-link">link</a></div>
   <div class="discussion-message">Actually, the custom controller factory was not even running because I commented it out.<br />
<br />
However, when I turn it back on, I actually get the same result:<br />
<pre><code>Server Error in '/' Application.

The resource cannot be found.

Description: HTTP 404. The resource you are looking for (or one of its dependencies) could have been removed, had its name changed, or is temporarily unavailable.  Please review the following URL and make sure that it is spelled correctly. 

Requested URL: /Arena

Version Information: Microsoft .NET Framework Version:4.0.30319; ASP.NET Version:4.0.30319.18408</code></pre>

It's just that I get it as a caught exception because I'm manually calling this:<br />
<pre><code>                var controller = VersionOne.Web.IceNine.Shim.IceNineCore.OriginalControllerFactory.CreateController(requestContext, controllerName);</code></pre>

That is delegating to the default Mvc Controller factory that I stored in that variable before replacing it with the custom controller.<br />
<br />
So, it looks like Mvc itself is having trouble finding the controller.<br />
<br />
Could it be something to do with it's name and namespace?<br />
<br />
I am trying to track it down in this code: <a href="https://github.com/ASP-NET-MVC/aspnetwebstack/blob/master/src/System.Web.Mvc/DefaultControllerFactory.cs#L194-L242" rel="nofollow">https://github.com/ASP-NET-MVC/aspnetwebstack/blob/master/src/System.Web.Mvc/DefaultControllerFactory.cs#L194-L242</a><br />
</div>
</div>
<div id="post1203012" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T07:24:03.23-08:00" title="2014-02-05T07:24:03.23-08:00">February 5, 2014</time> <a href="#post1203012" class="post-link">link</a></div>
   <div class="discussion-message">If you send me the solution to <a href="mailto:maxtoroq@gmail.com" rel="nofollow">maxtoroq@gmail.com</a> I can take a look.<br />
</div>
</div>
<div id="post1203015" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T07:27:18.747-08:00" title="2014-02-05T07:27:18.747-08:00">February 5, 2014</time> <a href="#post1203015" class="post-link">link</a></div>
   <div class="discussion-message">I'd like to, but it's in the code our of product and the solution is pretty huge. I'm debugging with the MS Symbols right now so I can step into MVC.<br />
<br />
If I can't solve it that way, maybe we can set up a screen share and look at it that way? I have a GoToMeeting account that we use all the time to work remotely with people.<br />
<br />
Thanks Max!<br />
</div>
</div>
<div id="post1203017" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T07:32:16.58-08:00" title="2014-02-05T07:32:16.58-08:00">February 5, 2014</time> <a href="#post1203017" class="post-link">link</a></div>
   <div class="discussion-message">Maybe you can try to create a new MVC app, copy the controllers and try to run it, it should work.<br />
</div>
</div>
<div id="post1203033" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T08:04:23.973-08:00" title="2014-02-05T08:04:23.973-08:00">February 5, 2014</time> <a href="#post1203033" class="post-link">link</a></div>
   <div class="discussion-message">Incredibly, it seems that the MVC code does not account for the idea of dynamically loaded assemblies, such as those loaded by MEF.<br />
<br />
Here's what I've figured out:<br />
<br />
This bit of code, TypeCacheUtil.GetFilteredTypesFromAssemblies looks only at assemblies &quot;referenced by the application&quot;:<br />
<br />
For now, I'm going to try setting an actual hard-reference to the assembly and see what that does. If that solves it, then I'll see about modifying MVC and submitting a pull request, or resort to something like these guys:<br />
<br />
<a href="http://blogs.microsoft.co.il/bnaya/2013/11/11/asp-net-web-api-minimal-touch-mef/" rel="nofollow">http://blogs.microsoft.co.il/bnaya/2013/11/11/asp-net-web-api-minimal-touch-mef/</a><br />
<a href="http://www.hanselman.com/blog/ExtendingNerdDinnerAddingMEFAndPluginsToASPNETMVC.aspx" rel="nofollow">http://www.hanselman.com/blog/ExtendingNerdDinnerAddingMEFAndPluginsToASPNETMVC.aspx</a><br />
<pre><code>    internal static class TypeCacheUtil
    {
        private static IEnumerable&lt;Type&gt; FilterTypesInAssemblies(IBuildManager buildManager, Predicate&lt;Type&gt; predicate)
        {
            // Go through all assemblies referenced by the application and search for types matching a predicate
            IEnumerable&lt;Type&gt; typesSoFar = Type.EmptyTypes;

            ICollection assemblies = buildManager.GetReferencedAssemblies();
            foreach (Assembly assembly in assemblies)
            {
                Type[] typesInAsm;
                try
                {
                    typesInAsm = assembly.GetTypes();
                }
                catch (ReflectionTypeLoadException ex)
                {
                    typesInAsm = ex.Types;
                }
                typesSoFar = typesSoFar.Concat(typesInAsm);
            }
            return typesSoFar.Where(type =&gt; TypeIsPublicClass(type) &amp;&amp; predicate(type));
        }

        public static List&lt;Type&gt; GetFilteredTypesFromAssemblies(string cacheName, Predicate&lt;Type&gt; predicate, IBuildManager buildManager)
        {
            TypeCacheSerializer serializer = new TypeCacheSerializer();

            // first, try reading from the cache on disk
            List&lt;Type&gt; matchingTypes = ReadTypesFromCache(cacheName, predicate, buildManager, serializer);
            if (matchingTypes != null)
            {
                return matchingTypes;
            }

            // if reading from the cache failed, enumerate over every assembly looking for a matching type
            matchingTypes = FilterTypesInAssemblies(buildManager, predicate).ToList();

            // finally, save the cache back to disk
            SaveTypesToCache(cacheName, matchingTypes, buildManager, serializer);

            return matchingTypes;
        }</code></pre>

Here's what it gets called:<br />
<br />
``<br />
<pre><code>    public void EnsureInitialized(IBuildManager buildManager)
    {
        if (_cache == null)
        {
            lock (_lockObj)
            {
                if (_cache == null)
                {
                    List&lt;Type&gt; controllerTypes = TypeCacheUtil.GetFilteredTypesFromAssemblies(TypeCacheName, IsControllerType, buildManager);
                    var groupedByName = controllerTypes.GroupBy(
                        t =&gt; t.Name.Substring(0, t.Name.Length - &quot;Controller&quot;.Length),
                        StringComparer.OrdinalIgnoreCase);
                    _cache = groupedByName.ToDictionary(
                        g =&gt; g.Key,
                        g =&gt; g.ToLookup(t =&gt; t.Namespace ?? String.Empty, StringComparer.OrdinalIgnoreCase),
                        StringComparer.OrdinalIgnoreCase);
                }
            }
        }
    }

    public ICollection&lt;Type&gt; GetControllerTypes(string controllerName, HashSet&lt;string&gt; namespaces)
    {
        HashSet&lt;Type&gt; matchingTypes = new HashSet&lt;Type&gt;();

        ILookup&lt;string, Type&gt; namespaceLookup;
        if (_cache.TryGetValue(controllerName, out namespaceLookup))
        {
            // this friendly name was located in the cache, now cycle through namespaces
            if (namespaces != null)
            {
                foreach (string requestedNamespace in namespaces)
                {
                    foreach (var targetNamespaceGrouping in namespaceLookup)
                    {
                        if (IsNamespaceMatch(requestedNamespace, targetNamespaceGrouping.Key))
                        {
                            matchingTypes.UnionWith(targetNamespaceGrouping);
                        }
                    }
                }
            }
            else
            {
                // if the namespaces parameter is null, search *every* namespace
                foreach (var namespaceGroup in namespaceLookup)
                {
                    matchingTypes.UnionWith(namespaceGroup);
                }
            }
        }

        return matchingTypes;
    }</code></pre>

```<br />
</div>
</div>
<div id="post1203049" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T08:18:13.49-08:00" title="2014-02-05T08:18:13.49-08:00">February 5, 2014</time> <a href="#post1203049" class="post-link">link</a></div>
   <div class="discussion-message">An alternative to hard-reference, or dynamically loaded assemblies, is to simply save the assembly to Bin (assuming it was downloaded at runtime). That will trigger an app restart and MVC will find it.<br />
<br />
Long term, if dynamically loaded assemblies are important to you, you should provide your own controller factory that does the magic. I don't think the ASP.NET team will be thrilled to implement your corner case.<br />
</div>
</div>
<div id="post1203058" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T08:23:27.423-08:00" title="2014-02-05T08:23:27.423-08:00">February 5, 2014</time> <a href="#post1203058" class="post-link">link</a></div>
   <div class="discussion-message">Yes!! That was it!!!<br />
<br />
After I hard-set the reference to the module in the main Web project, the DeafultControllerFactory finds it, and I get this:<br />
<br />
The controller:<br />
<pre><code>type ArenaController() =
    inherit System.Web.Mvc.Controller()
    [&lt;MvcCodeRouting.Web.Mvc.DefaultAction&gt;]    
    member this.Get() =
        this.Content(&quot;Nothing to see here&quot;)

type public ArenaModule() = 
    inherit DefaultModule&lt;ArenaController&gt;()
    override this.GetBaseControllerRoute() = 
        &quot;Arena&quot;
</code></pre>

The request:<br />
<pre><code>http://localhost:12244/Arena/Get 

or

http://localhost:12244/Arena

or even

http://localhost:12244/Arena/</code></pre>

The result:<br />
<pre><code>Nothing to see here</code></pre>

Now, the last sticking point seems to be the embedded views.<br />
<br />
I got the F# to embed the view like this as a compiler flag:<br />
<br />
--resource:&quot;Views\Arena\Get.spark&quot;,&quot;VersionOne.Arena.Module.Views.Arena.Get.spark&quot;<br />
<br />
When I view the assembly with Reflector, I do see that it has a resource embedded:<br />
<pre><code>@{
    ViewBag.Title = &quot;Module Version&quot;;
}

You've found the Module Version view. It's not very thrilling yet.</code></pre>

I guess that's actual Razor syntax, not spark. But, is the issue with the name? I know you said  in<br />
<a href="https://github.com/maxtoroq/MvcCodeRouting/tree/master/docs/Embedded-Views.md" rel="nofollow">https://mvccoderouting.codeplex.com/wikipage?title=Embedded%20Views</a> that it should be &quot;assemblyName&quot; based, which is what I tried. The namespace is actually just VersionOne.Arena, while the DLL is VersionOne.Arena.Module.<br />
<br />
I get this message:<br />
<pre><code>The view 'Get' or its master was not found or no view engine supports the searched locations. The following locations were searched:
Arena/Web\Get.spark
Shared\Get.spark
Arena/Web\Get.shade
Shared\Get.shade</code></pre>

In any case, I'm much less concerned about this part for the purpose of our demo for Friday, because we can always just return a content body that containns full on HTML markup and embedded JavaScript or return a JS file as a result of another route call. No big deal there for now. But, I'll definitely want to figure out the embedding part for the long haul.<br />
<br />
Josh<br />
</div>
</div>
<div id="post1203060" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T08:26:13.64-08:00" title="2014-02-05T08:26:13.64-08:00">February 5, 2014</time> <a href="#post1203060" class="post-link">link</a></div>
   <div class="discussion-message"><strong>maxtoroq wrote:</strong><br />
<blockquote>
An alternative to hard-reference, or dynamically loaded assemblies, is to simply save the assembly to Bin (assuming it was downloaded at runtime). That will trigger an app restart and MVC will find it.<br />
<br />
Long term, if dynamically loaded assemblies are important to you, you should provide your own controller factory that does the magic. I don't think the ASP.NET team will be thrilled to implement your corner case.<br />
</blockquote>
The problem with putting the files into the bin\ folder is that when composing a catalog from it, many of the other types go crazy.<br />
<br />
But, I suppose I could filter the catalog to contain files only of a certain naming convention. I'm not sure if that's possible, but I'll check. I am not sure if that would actually solve the TypeCacheUtil thing or not. It sounded like it was actually reading references, not files in the bin folder, but maybe that's how it works internally.<br />
</div>
</div>
<div id="post1203094" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T09:10:45.153-08:00" title="2014-02-05T09:10:45.153-08:00">February 5, 2014</time> <a href="#post1203094" class="post-link">link</a></div>
   <div class="discussion-message">Actually, since it's working on Web API, I could do something similar on MVC. I'll look into it.<br />
</div>
</div>
<div id="post1203099" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T09:19:12.73-08:00" title="2014-02-05T09:19:12.73-08:00">February 5, 2014</time> <a href="#post1203099" class="post-link">link</a></div>
   <div class="discussion-message"><strong>JoshuaGough wrote:</strong><br />
<blockquote>
I guess that's actual Razor syntax, not spark. But, is the issue with the name? I know you said  in<br />
<a href="https://github.com/maxtoroq/MvcCodeRouting/tree/master/docs/Embedded-Views.md" rel="nofollow">https://mvccoderouting.codeplex.com/wikipage?title=Embedded%20Views</a> that it should be &quot;assemblyName&quot; based, which is what I tried. The namespace is actually just VersionOne.Arena, while the DLL is VersionOne.Arena.Module.<br />
</blockquote>
I think the assembly name and the root namespace must be the same. Try making that change.<br />
</div>
</div>
<div id="post1203113" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T09:45:43.677-08:00" title="2014-02-05T09:45:43.677-08:00">February 5, 2014</time> <a href="#post1203113" class="post-link">link</a></div>
   <div class="discussion-message"><strong>maxtoroq wrote:</strong><br />
<blockquote>
Actually, since it's working on Web API, I could do something similar on MVC. I'll look into it.<br />
</blockquote>
Oh, so you mean the fact that it loads from the dynamic modules? Yeah, that would be pretty awesome.<br />
</div>
</div>
<div id="post1203116" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T09:46:34.487-08:00" title="2014-02-05T09:46:34.487-08:00">February 5, 2014</time> <a href="#post1203116" class="post-link">link</a></div>
   <div class="discussion-message"><strong>maxtoroq wrote:</strong><br />
<blockquote>
<strong>JoshuaGough wrote:</strong><br />
<blockquote>
I guess that's actual Razor syntax, not spark. But, is the issue with the name? I know you said  in<br />
<a href="https://github.com/maxtoroq/MvcCodeRouting/tree/master/docs/Embedded-Views.md" rel="nofollow">https://mvccoderouting.codeplex.com/wikipage?title=Embedded%20Views</a> that it should be &quot;assemblyName&quot; based, which is what I tried. The namespace is actually just VersionOne.Arena, while the DLL is VersionOne.Arena.Module.<br />
</blockquote>
I think the assembly name and the root namespace must be the same. Try making that change.<br />
</blockquote>
I'm trying some stuff here. It's getting confusing for me at the moment. I may end up just embedded literal HTML and script code from a Controller method at least until the week is over. <br />
</div>
</div>
<div id="post1203121" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T10:00:10.13-08:00" title="2014-02-05T10:00:10.13-08:00">February 5, 2014</time> <a href="#post1203121" class="post-link">link</a></div>
   <div class="discussion-message"><strong>JoshuaGough wrote:</strong><br />
<blockquote>
<strong>maxtoroq wrote:</strong><br />
<blockquote>
<strong>JoshuaGough wrote:</strong><br />
<blockquote>
I guess that's actual Razor syntax, not spark. But, is the issue with the name? I know you said  in<br />
<a href="https://github.com/maxtoroq/MvcCodeRouting/tree/master/docs/Embedded-Views.md" rel="nofollow">https://mvccoderouting.codeplex.com/wikipage?title=Embedded%20Views</a> that it should be &quot;assemblyName&quot; based, which is what I tried. The namespace is actually just VersionOne.Arena, while the DLL is VersionOne.Arena.Module.<br />
</blockquote>
I think the assembly name and the root namespace must be the same. Try making that change.<br />
</blockquote>
I'm trying some stuff here. It's getting confusing for me at the moment. I may end up just embedded literal HTML and script code from a Controller method at least until the week is over.<br />
</blockquote>
I'm going to leave this part alone for now.<br />
<br />
Here's what I'm leaving off:<br />
<br />
Code:<br />
<br />
Here, the dll is named VersionOne.Arena.Module.dll, and the namespaces all have VersionOne.Arena.Module.<br />
<br />
My API routes are fine:<br />
<br />
<a href="http://localhost:12244/Arena/Api returns the message as expected" rel="nofollow">http://localhost:12244/Arena/Api returns the message as expected</a>. As dothe Version/ and ByName?name=blah endpoints<br />
<br />
When I hit: <a href="http://localhost:12244/Arena I get the &quot;nothing to see&quot; message as expected" rel="nofollow">http://localhost:12244/Arena I get the "nothing to see" message as expected</a>.<br />
<pre><code>namespace VersionOne.Arena.Module

open System
open System.Web.Http
open System.Net.Http
open System.Net
open VersionOne.Arena.Intrastructure.Web

type ArenaController() =
    inherit System.Web.Mvc.Controller()
    [&lt;MvcCodeRouting.Web.Mvc.DefaultAction&gt;]    
    member this.Get() =
        this.Content(&quot;Nothing to see here&quot;)

type public ArenaModule() = 
    inherit DefaultModule&lt;ArenaController&gt;()
    override this.GetBaseControllerRoute() = 
        &quot;Arena&quot;

namespace VersionOne.Arena.Module.Api

open System
open System.Web.Http
open System.Net.Http
open System.Net
open VersionOne.Arena.Intrastructure.Web

type ApiController() =
    inherit System.Web.Http.ApiController()
    member this.Get () = &quot;We got it! Here's your messages!&quot;

    [&lt;HttpGet&gt;]
    member this.ByName name = &quot;Thanks! Here's your name: &quot; + name

    [&lt;HttpGet&gt;]
    member this.Version () = &quot;Version B&quot;

    [&lt;HttpGet&gt;]
    member this.NewEndpoint () = &quot;Hey I did not exist in Version A!&quot;

namespace VersionOne.Arena.Module.Web

open System
open System.Web.Http
open System.Net.Http
open System.Net
open VersionOne.Arena.Intrastructure.Web

type WebController() =
    inherit System.Web.Mvc.Controller()    
    [&lt;MvcCodeRouting.Web.Mvc.DefaultAction&gt;]    
    member this.Get() = 
        this.View(&quot;Get&quot;) 
        // Also tried this:
       // this.View()</code></pre>

But, when I hit Arena/Web I get:<br />
<pre><code>[InvalidOperationException: The view 'Get' or its master was not found or no view engine supports the searched locations. The following locations were searched:
Arena/Web\Get.spark
Shared\Get.spark
Arena/Web\Get.shade
Shared\Get.shade]
   System.Web.Mvc.ViewResult.FindView(ControllerContext context) +504
   System.Web.Mvc.ViewResultBase.ExecuteResult(ControllerContext context) +230
   System.Web.Mvc.ControllerActionInvoker.InvokeActionResult(ControllerContext controllerContext, ActionResult actionResult) +39
   System.Web.Mvc.ControllerActionInvoker.InvokeActionResultFilterRecursive(IList`1 filters, Int32 filterIndex, ResultExecutingContext preContext, ControllerContext controllerContext, ActionResult actionResult) +116
   System.Web.Mvc.ControllerActionInvoker.InvokeActionResultFilterRecursive(IList`1 filters, Int32 filterIndex, ResultExecutingContext preContext, ControllerContext controllerContext, ActionResult actionResult) +529
   System.Web.Mvc.ControllerActionInvoker.InvokeActionResultWithFilters(ControllerContext controllerContext, IList`1 filters, ActionResult actionResult) +106
   System.Web.Mvc.Async.&lt;&gt;c__DisplayClass2b.&lt;BeginInvokeAction&gt;b__1c() +321
   System.Web.Mvc.Async.&lt;&gt;c__DisplayClass21.&lt;BeginInvokeAction&gt;b__1e(IAsyncResult asyncResult) +185
   System.Web.Mvc.Async.WrappedAsyncResult`1.CallEndDelegate(IAsyncResult asyncResult) +42
   System.Web.Mvc.Async.WrappedAsyncResultBase`1.End() +133
   System.Web.Mvc.Async.AsyncResultWrapper.End(IAsyncResult asyncResult, Object tag) +56
   System.Web.Mvc.Async.AsyncControllerActionInvoker.EndInvokeAction(IAsyncResult asyncResult) +40
   System.Web.Mvc.Controller.&lt;BeginExecuteCore&gt;b__1d(IAsyncResult asyncResult, ExecuteCoreState innerState) +34
   System.Web.Mvc.Async.WrappedAsyncVoid`1.CallEndDelegate(IAsyncResult asyncResult) +70
   System.Web.Mvc.Async.WrappedAsyncResultBase`1.End() +139
   System.Web.Mvc.Async.AsyncResultWrapper.End(IAsyncResult asyncResult, Object tag) +59
   System.Web.Mvc.Async.AsyncResultWrapper.End(IAsyncResult asyncResult, Object tag) +40
   System.Web.Mvc.Controller.EndExecuteCore(IAsyncResult asyncResult) +44
   System.Web.Mvc.Controller.&lt;BeginExecute&gt;b__15(IAsyncResult asyncResult, Controller controller) +39
   System.Web.Mvc.Async.WrappedAsyncVoid`1.CallEndDelegate(IAsyncResult asyncResult) +62
   System.Web.Mvc.Async.WrappedAsyncResultBase`1.End() +139
   System.Web.Mvc.Async.AsyncResultWrapper.End(IAsyncResult asyncResult, Object tag) +59
   System.Web.Mvc.Async.AsyncResultWrapper.End(IAsyncResult asyncResult, Object tag) +40
   System.Web.Mvc.Controller.EndExecute(IAsyncResult asyncResult) +39
   System.Web.Mvc.Controller.System.Web.Mvc.Async.IAsyncController.EndExecute(IAsyncResult asyncResult) +39
   System.Web.Mvc.MvcHandler.&lt;BeginProcessRequest&gt;b__5(IAsyncResult asyncResult, ProcessRequestState innerState) +39
   System.Web.Mvc.Async.WrappedAsyncVoid`1.CallEndDelegate(IAsyncResult asyncResult) +70
   System.Web.Mvc.Async.WrappedAsyncResultBase`1.End() +139
   System.Web.Mvc.Async.AsyncResultWrapper.End(IAsyncResult asyncResult, Object tag) +59
   System.Web.Mvc.Async.AsyncResultWrapper.End(IAsyncResult asyncResult, Object tag) +40
   System.Web.Mvc.MvcHandler.EndProcessRequest(IAsyncResult asyncResult) +40
   System.Web.Mvc.MvcHandler.System.Web.IHttpAsyncHandler.EndProcessRequest(IAsyncResult result) +38
   System.Web.CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute() +9514812
   System.Web.HttpApplication.ExecuteStep(IExecutionStep step, Boolean&amp; completedSynchronously) +155</code></pre>

In my compiler options, I have this:<br />
<br />
--resource:&quot;Views\Arena\Web\Get.spark&quot;,&quot;VersionOne.Arena.Module.Views.Arena.Web.Get.spark&quot;<br />
<br />
And, viewing the assembly under JustDecompile verifies that the resource is embedded, as does stepping into MvcCodeRouting code and seeing that it is getting added to the ViewResources list.<br />
</div>
</div>
<div id="post1203138" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T10:40:03.753-08:00" title="2014-02-05T10:40:03.753-08:00">February 5, 2014</time> <a href="#post1203138" class="post-link">link</a></div>
   <div class="discussion-message">It's weird that the error message says<br />
<blockquote>
The following locations were searched:<br />
Arena/Web\Get.spark<br />
Shared\Get.spark<br />
Arena/Web\Get.shade<br />
Shared\Get.shade<br />
</blockquote>
instead of:<br />
<blockquote>
The following locations were searched:<br />
~/Views/Arena/Web/Get.spark<br />
~/Views/Shared/Get.spark<br />
~/Views/Arena/Web/Get.shade<br />
~/Views/Shared/Get.shade<br />
</blockquote>
Does it work with if you use Razor views?<br />
</div>
</div>
<div id="post1203163" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T11:40:35.433-08:00" title="2014-02-05T11:40:35.433-08:00">February 5, 2014</time> <a href="#post1203163" class="post-link">link</a></div>
   <div class="discussion-message">Hmm..yeah that is weird.<br />
<br />
I haven't tried yet. We have some code that &quot;clears&quot; all view engines. Maybe I should comment that out.<br />
</div>
</div>
<div id="post1203176" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T12:25:05.873-08:00" title="2014-02-05T12:25:05.873-08:00">February 5, 2014</time> <a href="#post1203176" class="post-link">link</a></div>
   <div class="discussion-message"><strong>JoshuaGough wrote:</strong><br />
<blockquote>
<strong>maxtoroq wrote:</strong><br />
<blockquote>
Actually, since it's working on Web API, I could do something similar on MVC. I'll look into it.<br />
</blockquote>
Oh, so you mean the fact that it loads from the dynamic modules? Yeah, that would be pretty awesome.<br />
</blockquote>
It was very easy to implement, if you have a local clone checkout the controller-factory branch. You need to call <code>ControllerBuilder.Current.EnableCodeRouting()</code> which sets a custom controller factory. I cannot make this a default because lot's of people, like yourself, use a custom controller factory for other purposes, like dependency injection, although on that case they should be using a custom controller activator instead.<br />
</div>
</div>
<div id="post1203244" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T15:27:18.473-08:00" title="2014-02-05T15:27:18.473-08:00">February 5, 2014</time> <a href="#post1203244" class="post-link">link</a></div>
   <div class="discussion-message">So I have not gotten a chance to try that yet.<br />
<br />
I got the basic approach of a plugin loader working including a lightweight Angular JS front end. <br />
<br />
I did end up just copying the dlls into the bin folder from a parallel Plugins folder. Since asp.net automatically restarts when that happen it works out well. Using MEF is less important for this baseline scenario. Later on we want to be able to modularized on a per user basis, so having the ability to list components in catalog will be useful. <br />
<br />
There is an overload for DirectoryCatalog which takes a file glob so that worked to prevent scanning of useless dlls.<br />
<br />
I am going to try tomorrow to utilize NuGet.Core so that the modules themselves can be pulled in via a.private nuget feed per the Pro NuGet book's recipe. <br />
<br />
So, I'd still like to get the embedded views working but it might not be until after this week that I get back into it.<br />
<br />
Thanks for all your help so far.<br />
<br />
If the rest of our team digs this, we may seek more help. By the way, do you ever do any side consulting?  <br />
</div>
</div>
<div id="post1203264" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T17:12:43.69-08:00" title="2014-02-05T17:12:43.69-08:00">February 5, 2014</time> <a href="#post1203264" class="post-link">link</a></div>
   <div class="discussion-message"><strong>JoshuaGough wrote:</strong><br />
<blockquote>
So, I'd still like to get the embedded views working but it might not be until after this week that I get back into it.<br />
</blockquote>
Maybe there's some kind of incompatibility with the Spark view engine, if you want to do a screen share tomorrow I can help you figure it out.<br />
<br />
<strong>JoshuaGough wrote:</strong><br />
<blockquote>
If the rest of our team digs this, we may seek more help. By the way, do you ever do any side consulting?<br />
</blockquote>
I do, if you are interested in my services email me at <a href="mailto:maxtoroq@gmail.com" rel="nofollow">maxtoroq@gmail.com</a> and we can discuss further :-)<br />
</div>
</div>
<div id="post1203269" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T17:37:08.16-08:00" title="2014-02-05T17:37:08.16-08:00">February 5, 2014</time> <a href="#post1203269" class="post-link">link</a></div>
   <div class="discussion-message">I removed the &quot;ViewEngines.Clear()&quot; statement, and now I get this:<br />
<br />
The view 'Get' or its master was not found or no view engine supports the searched locations. The following locations were searched:<br />
~/Views/Arena/Web/Get.aspx<br />
~/Views/Arena/Web/Get.ascx<br />
~/Views/Shared/Get.aspx<br />
~/Views/Shared/Get.ascx<br />
~/Views/Arena/Web/Get.cshtml<br />
~/Views/Arena/Web/Get.vbhtml<br />
~/Views/Shared/Get.cshtml<br />
~/Views/Shared/Get.vbhtml<br />
Arena/Web\Get.spark<br />
Shared\Get.spark<br />
Arena/Web\Get.shade<br />
Shared\Get.shade<br />
<br />
Description: An unhandled exception occurred during the execution of the current web request. Please review the stack trace for more information about the error and where it originated in the code. <br />
<br />
Exception Details: System.InvalidOperationException: The view 'Get' or its master was not found or no view engine supports the searched locations. The following locations were searched:<br />
~/Views/Arena/Web/Get.aspx<br />
~/Views/Arena/Web/Get.ascx<br />
~/Views/Shared/Get.aspx<br />
~/Views/Shared/Get.ascx<br />
~/Views/Arena/Web/Get.cshtml<br />
~/Views/Arena/Web/Get.vbhtml<br />
~/Views/Shared/Get.cshtml<br />
~/Views/Shared/Get.vbhtml<br />
Arena/Web\Get.spark<br />
Shared\Get.spark<br />
Arena/Web\Get.shade<br />
Shared\Get.shade<br />
<br />
My view name is like this in the Assembly itself under JustDecompile:<br />
<br />
VersionOne.Arena.Module.Views.Arena.Web.Get.cshtml<br />
<br />
And it has this content:<br />
<pre><code>@{
    ViewBag.Title = &quot;Module Version&quot;;
}

You've found the Module Version view. It's not very thrilling yet.</code></pre>

I'm going to try removing .Module. from its name....<br />
<br />
<strong>maxtoroq wrote:</strong><br />
<blockquote>
<strong>JoshuaGough wrote:</strong><br />
<blockquote>
So, I'd still like to get the embedded views working but it might not be until after this week that I get back into it.<br />
</blockquote>
Maybe there's some kind of incompatibility with the Spark view engine, if you want to do a screen share tomorrow I can help you figure it out.<br />
<br />
<strong>JoshuaGough wrote:</strong><br />
<blockquote>
If the rest of our team digs this, we may seek more help. By the way, do you ever do any side consulting?<br />
</blockquote>
I do, if you are interested in my services email me at <a href="mailto:maxtoroq@gmail.com" rel="nofollow">maxtoroq@gmail.com</a> and we can discuss further :-)<br />
</blockquote>
</div>
</div>
<div id="post1203273" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T17:47:57.873-08:00" title="2014-02-05T17:47:57.873-08:00">February 5, 2014</time> <a href="#post1203273" class="post-link">link</a></div>
   <div class="discussion-message">Same result when I removed .Module. from the resource name:<br />
<br />
The view 'Get' or its master was not found or no view engine supports the searched locations. The following locations were searched:<br />
~/Views/Arena/Web/Get.aspx<br />
~/Views/Arena/Web/Get.ascx<br />
~/Views/Shared/Get.aspx<br />
~/Views/Shared/Get.ascx<br />
~/Views/Arena/Web/Get.cshtml<br />
~/Views/Arena/Web/Get.vbhtml<br />
~/Views/Shared/Get.cshtml<br />
~/Views/Shared/Get.vbhtml<br />
Arena/Web\Get.spark<br />
Shared\Get.spark<br />
Arena/Web\Get.shade<br />
Shared\Get.shade<br />
<br />
Maybe I will try removing Spark entirely? :D<br />
</div>
</div>
<div id="post1203274" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T17:58:29.913-08:00" title="2014-02-05T17:58:29.913-08:00">February 5, 2014</time> <a href="#post1203274" class="post-link">link</a></div>
   <div class="discussion-message">Can you email me the DLL only?<br />
</div>
</div>
<div id="post1203277" class="discussion-comment">
   <div class="discussion-header">Commented on 
      <time datetime="2014-02-05T18:27:33.597-08:00" title="2014-02-05T18:27:33.597-08:00">February 5, 2014</time> <a href="#post1203277" class="post-link">link</a></div>
   <div class="discussion-message">sure! Sending now<br />
</div>
</div>